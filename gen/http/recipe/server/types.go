// Code generated by goa v2.0.0-wip, DO NOT EDIT.
//
// recipe HTTP server types
//
// Command:
// $ goa gen github.com/jaredwarren/rx/design

package server

import (
	recipeviews "github.com/jaredwarren/rx/gen/recipe/views"
	goa "goa.design/goa"
)

// ListResponseBody is the type of the "recipe" service "list" endpoint HTTP
// response body.
type ListResponseBody []*RxRecipeResponseBody

// RxRecipeResponseBody is used to define fields on response body types.
type RxRecipeResponseBody struct {
	// Unique recipe ID
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Recipe Title
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Long description of recipe
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Version Number e.g. 1.0.1
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// List of ingredients
	Ingredients *IngredientListResponseBody `form:"ingredients,omitempty" json:"ingredients,omitempty" xml:"ingredients,omitempty"`
	// Is a favorite, basically a tag
	Favorite *bool `form:"favorite,omitempty" json:"favorite,omitempty" xml:"favorite,omitempty"`
	// rating between 0-1
	Rating *float32 `form:"rating,omitempty" json:"rating,omitempty" xml:"rating,omitempty"`
	// rating between 0-1
	Difficulty *float32 `form:"difficulty,omitempty" json:"difficulty,omitempty" xml:"difficulty,omitempty"`
	// e.g. chopped, sliced, etc.. might need to be array.
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// If it's been added/included
	Complete *bool `form:"complete,omitempty" json:"complete,omitempty" xml:"complete,omitempty"`
}

// IngredientListResponseBody is used to define fields on response body types.
type IngredientListResponseBody struct {
	// List of ingredients
	Ingredients []*IngredientResponseBody `form:"ingredients,omitempty" json:"ingredients,omitempty" xml:"ingredients,omitempty"`
}

// IngredientResponseBody is used to define fields on response body types.
type IngredientResponseBody struct {
	Recipe *RxRecipeResponseBody `form:"recipe,omitempty" json:"recipe,omitempty" xml:"recipe,omitempty"`
	// TODO: make UnitOfMeasure
	Quantity *string `form:"quantity,omitempty" json:"quantity,omitempty" xml:"quantity,omitempty"`
}

// NewListResponseBody builds the HTTP response body from the result of the
// "list" endpoint of the "recipe" service.
func NewListResponseBody(res recipeviews.RxRecipeCollectionView) ListResponseBody {
	body := make([]*RxRecipeResponseBody, len(res))
	for i, val := range res {
		body[i] = &RxRecipeResponseBody{
			ID:          val.ID,
			Title:       val.Title,
			Description: val.Description,
			Version:     val.Version,
			Favorite:    val.Favorite,
			Rating:      val.Rating,
			Difficulty:  val.Difficulty,
			State:       val.State,
			Complete:    val.Complete,
		}
		if val.Ingredients != nil {
			body[i].Ingredients = marshalIngredientListViewToIngredientListResponseBody(val.Ingredients)
		}
	}
	return body
}

// Validate runs the validations defined on RxRecipeResponseBody
func (body *RxRecipeResponseBody) Validate() (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Ingredients != nil {
		if err2 := body.Ingredients.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Rating != nil {
		if *body.Rating < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rating", *body.Rating, 0, true))
		}
	}
	if body.Rating != nil {
		if *body.Rating > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rating", *body.Rating, 1, false))
		}
	}
	if body.Difficulty != nil {
		if *body.Difficulty < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.difficulty", *body.Difficulty, 0, true))
		}
	}
	if body.Difficulty != nil {
		if *body.Difficulty > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.difficulty", *body.Difficulty, 1, false))
		}
	}
	return
}

// Validate runs the validations defined on IngredientListResponseBody
func (body *IngredientListResponseBody) Validate() (err error) {
	for _, e := range body.Ingredients {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Validate runs the validations defined on IngredientResponseBody
func (body *IngredientResponseBody) Validate() (err error) {
	if body.Recipe != nil {
		if err2 := body.Recipe.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}
